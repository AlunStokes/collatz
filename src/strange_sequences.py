from math import sqrt, log2, log
import operator as op
from functools import reduce
from itertools import combinations
from scipy.special import comb

import matplotlib.pyplot as plt

#a is |A|, b is |b|
def get_all_r(a ,b):
    L = []
    M = list(combinations(list(range(1, b + 1)), a))
    for m in M:
        A = []
        r = 0
        for i, p in enumerate(m[::-1]):
            A.append(p)
            r += 3**(i) * 2**(p - 1)
        #L.append((tuple(A[::-1]), r))
        L.append(r)
    return L

def phi(x):
    if x == 0:
        return 0
    i = 1
    while True:
        if x % 2**i != 0:
            return i - 1
        i += 1

def r_func(A):
    r = 0
    i = 1
    while i <= len(A):
        r += 3**(i-1) * 2**(A[len(A) - i] - 1)
        i += 1
    return r

def inv_r(r, n):
    L = []
    i = 0
    while i < n:
        s = 0
        j = 0
        while j < i:
            s += 3**(n-(j+1)) * 2**(L[j] - 1)
            j += 1
        L.append(phi(r - s) + 1)
        i += 1
    return tuple(L)

def in_Rn(r, n):
    if n == 0 and r == 0:
        return True
    elif n == 0 and r != 0:
        return False
    for i in range(n-1, 0, -1):
        r = r // 2**phi(r)
        r -= 3**i

    if 2**phi(r) != r:
        return False
    return True

def generate_sequence(a, b):
    S = []
    n = b - a
    s = []
    i = 0
    while i < n:
        s.append(12 * (2**(i + 1) - 1))
        i += 1
    S.append(s)
    i = 2
    while i <= n + 1:
        s = []
        j = 1
        while j <= n - i + 2:
            s.append(6 * (2**(j + i - 1) + 6 * (2**(i - 2) - 1) + 1))
            j += 1
        S.append(s)
        i += 1
    R = [i for s in S for i in s]
    return R


if __name__ == '__main__':
    #a is the length of the sequences being generated
    a = 5
    #b is the upper bound for the largest element  of the sets we are looking at
    b = 2*a + 8

    #The set of all r generated by sequences of length a and with maximum element <= b
    R = get_all_r(a, b)
    #The set of sequences generating each r
    A = [inv_r(r,a) for r in R]

    #the sequence for 4^a - 3^a
    ref_A = tuple(range(1, 2*a, 2))
    ref_r = 4**a - 3**a

    #Q is a list of lists that partitions the r in R by the last value in their generating sequence
    Q = [[r for a, r in zip(A, R) if max(a) == i] for i in range(a, b + 1)]

    #For each list in Q, we print out
    for i, q in enumerate(Q):
        #Prints "{max element} [{minimum element of this set} - {maximum element of this set}]"
        print('{} [{} - {}]'.format(i + a, 2**(i  + a - 1) + 3 * (3**(a - 1) - 2**(a - 1)), 2**(i) * (3**a - 2**a) ))
        #M stars by simply recording each r in the current set
        M = []
        for r in q:
            if r % 2 == 1:
                M.append(r)
                #uncommenting the following (and indenting the lines beneath) will print only the r that are scalar multiples
                #of 4^a - 3^a
                #if p % ref_r == 0:
                A = inv_r(r, a)
                #Prints "{r}: {generating sequence of r}"
                print('{}: {}'.format(r, A))
        #Each m in M is used to find the difference from the initial element
        #This is the sequence we are looking at
        M = [M[i] - M[0] for i in range(1, len(M))]
        print(M)
        print(M == generate_sequence(a, i + a))
        print('')
        if len(M) == 0:
            continue
        plt.plot(M, label='{}'.format(i + a))
        #Comment the line below if you want to see the M for each set stacked
        #plt.show()

    plt.legend()
    plt.show()
